# name: BB_SftpPollerCreateOrder
# version: 1.0
# desc: class for polling for files from an SFTP server and creating a workflow order from them
# author: Qore Technologies, s.r.o.
# requires: BB_SftpPollerBase
# requires: BB_CreateOrder
%new-style
%require-types
%strict-args
%enable-all-warnings

%requires SftpPoller

#! this base building block polls an SFTP server for files
/**
*/
class BB_SftpPollerCreateOrder inherits BB_SftpPollerBase, BB_CreateOrder {
    #! called for each matching file individually whenever matching files are polled with the list of matching file names; if any error occurs here, the error is logged and the polling operation is retried
    /** @param fih a hash of file data and information with the following keys:
        - \c name: the name of the file, link, or directory
        - \c size: the size of the file in bytes
        - \c uid: the UID of the owner of the file
        - \c gid: the GID of the owner of the file
        - \c mode: the permissions / mode of the file
        - \c atime: the last accessed date/time of the file
        - \c mtime: the last modified date/time of the file
        - \c type: the type of file; one of: \c "REGULAR", \c "DIRECTORY", \c "SYMBOLIC-LINK", \c "BLOCK-DEVICE",
          \c "CHARACTER-DEVICE", \c "FIFO", \c "SYMBOLIC-LINK", \c "SOCKET", or \c "UNKNOWN"
        - \c perm: a string giving UNIX-style permissions for the file (ex: "-rwxr-xr-x")
        - \c data: this key is only present if \c sftp-polling-file-connection not set; in this case the remote file
          data is retrieved in memory and stored in this key as binary data
        - \c filepath: the remote filepath relative to SFTP root directory
        - \c local_path: this key is set to a string giving the local path where the file's data is stored if
          config item \c sftp-polling-file-connection is set

        @return the event with the following additional keys:
        - \c order_status: the status of the new order created
        - \c workflow_instanceid: the workflow instance ID of the new order created
    */
    hash<auto> singleFileEventImpl(hash<auto> event) {
        hash<CreateOrderOptionInfo> create_opts();
        bool dup = False;
        int wfiid = createWorkflowOrder(event, create_opts, \dup);
        event += {
            "workflow_instanceid": wfiid,
            "order_status": create_opts.status,
            "duplicate": dup,
        };
        if (dup) {
            # get real order status
            hash<auto> info = UserApi::callRestApi("GET", "orders/" + wfiid);
            event.order_status = info.workflowstatus;

            # if the order has step info, then the file is a duplicate file
            if (info.StepInstances) {
                # check for duplicate file processing if there is a local file
                if (event.local_path) {
                    *string dup_target = UserApi::getConfigItemValue("sftp-polling-duplicate-file-connection", event);
                    if (dup_target) {
                        dup_target = UserApi::getUserConnection(dup_target).path();
                        {
                            *string path_offset = UserApi::getConfigItemValue("sftp-polling-duplicate-file-path", event);
                            if (path_offset) {
                                dup_target = normalize_dir(dup_target + DirSep + path_offset);
                            }
                        }
                        dup_target = normalize_dir(dup_target + DirSep +
                            UserApi::getConfigItemValue("sftp-polling-duplicate-name-template", event));

                        UserApi::logInfo("DUPLICATE FILE %y found: workflow_instanceid %d has status %y (%d step%s); "
                            "moving %y -> %y", event.name, wfiid, event.order_status, info.StepInstances.size(),
                            info.StepInstances.size() == 1 ? "" : "s", event.tmp_path, dup_target);

                        # move file to duplicate target location
                        rename(event.tmp_path, dup_target);

                        # set local path to the new location of the file
                        event += {
                            "local_path": dup_target,
                            "new_name": basename(dup_target),
                        };
                        # remove tmp_path so the base class will not try to move a file that's already been moved
                        remove event.tmp_path;
                    }

                    if ((*string dup_workflow = UserApi::getConfigItemValue("sftp-polling-duplicate-workflow-name"))
                        && (*string dup_mapper = UserApi::getConfigItemValue("sftp-polling-duplicate-order-mapper"))) {
                        wfiid = createWorkflowOrder(event, <CreateOrderOptionInfo>{
                            "workflow": dup_workflow,
                            "version": UserApi::getConfigItemValue("sftp-polling-duplicate-workflow-version"),
                            "status": OMQ::StatReady,
                            "mapper": dup_mapper,
                        });
                        UserApi::logInfo("created %s order workflow_instanceid %d", dup_workflow, wfiid);
                        event.duplicate_workflow_instanceid = wfiid;
                    }
                } else {
                    UserApi::logInfo("DUPLICATE FILE %y found: workflow_instanceid %d has status %y (%d step%s); "
                        "no local file to handle",
                        event.name, wfiid, event.order_status, info.StepInstances.size(),
                        info.StepInstances.size() == 1 ? "" : "s");
                }
            }
        }
        return event;
    }

    #! called for each matching file individually whenever matching files are polled with the list of matching file names; if any error occurs here, the error is logged and the polling operation is retried
    /** @param fih a hash of file data and information with the following keys:
        - \c name: the name of the file, link, or directory
        - \c size: the size of the file in bytes
        - \c uid: the UID of the owner of the file
        - \c gid: the GID of the owner of the file
        - \c mode: the permissions / mode of the file
        - \c atime: the last accessed date/time of the file
        - \c mtime: the last modified date/time of the file
        - \c type: the type of file; one of: \c "REGULAR", \c "DIRECTORY", \c "SYMBOLIC-LINK", \c "BLOCK-DEVICE",
          \c "CHARACTER-DEVICE", \c "FIFO", \c "SYMBOLIC-LINK", \c "SOCKET", or \c "UNKNOWN"
        - \c perm: a string giving UNIX-style permissions for the file (ex: "-rwxr-xr-x")
        - \c data: this key is only present if \c sftp-polling-file-connection not set; in this case the remote file
          data is retrieved in memory and stored in this key as binary data
        - \c filepath: the remote filepath relative to SFTP root directory
        - \c local_path: this key is set to a string giving the local path where the file's data is stored if
          config item \c sftp-polling-file-connection is set

        If config item \c sftp-polling-delete-file is true, then the remote file is deleted here.

        Otherwise, if \c sftp-polling-move-target is true, then the remove file is moved to the target location on the
        remove server here.
    */
    hash<auto> postSingleFileEvent(hash<auto> event) {
        event = BB_SftpPollerBase::postSingleFileEvent(event);
        # now unblock the order if necessary
        if (event.order_status == OMQ::StatBlocked) {
            UserApi::unblockOrder(event.workflow_instanceid);
            UserApi::logInfo("unblocked order %d for further processing", event.workflow_instanceid);
        }
        return event;
    }

    #! config items for this object defined in BB_SftpPollerBase and BB_CreateOrder
    /** the \c create-workflow-order-status default value is set to @ref OMQ::StatBlocked "BLOCKED"
    */
    static hash<string, hash<ConfigItemInfo>> getConfigItems() {
        hash<string, hash<ConfigItemInfo>> rv = BB_SftpPollerBase::getConfigItems()
            + BB_CreateOrder::getConfigItems() + {
            "sftp-polling-duplicate-file-connection": <ConfigItemInfo>{
                "type": "*string",
                "default_value": NOTHING,
                "description": "the name of a local file connection where to save duplicate files; "
                    "\"sftp-polling-duplicate-file-path\" can be set to give a subdirectory path offset from the "
                    "connection",
                "strictly_local": True,
                "config_group": "SFTP Polling Workflow Creation Duplicate File Handling",
            },
            "sftp-polling-duplicate-file-path": <ConfigItemInfo>{
                "type": "*string",
                "default_value": NOTHING,
                "description": "a subdirectory path offset from the connection identified with "
                    "\"sftp-polling-duplicate-file-connection\"; ignored if "
                    "\"sftp-polling-duplicate-file-connection\" is not set",
                "strictly_local": True,
                "config_group": "SFTP Polling Workflow Creation Duplicate File Handling",
            },
            "sftp-polling-duplicate-name-template": <ConfigItemInfo>{
                "type": "string",
                "default_value": "$local:name-$timestamp:{YYYY-MM-DD HH:mm:SS.xx}",
                "description": "the filename template for the target file when moving duplicate files; only used if "
                    "\"sftp-polling-file-connection\" and \"sftp-polling-duplicate-file-connection\" are set; the "
                    "filesystem event info is available in the local context",
                "strictly_local": True,
                "config_group": "SFTP Polling Workflow Creation Duplicate File Handling",
            },
            "sftp-polling-duplicate-workflow-name": <ConfigItemInfo>{
                "type": "*string",
                "default_value": NOTHING,
                "description": "the name of the workflow for duplicate file handling; if not set (the default), no "
                    "workflow order will be created; only used if \"sftp-polling-file-connection\" and "
                    "\"sftp-polling-duplicate-order-mapper\" are also set",
                "strictly_local": True,
                "config_group": "SFTP Polling Workflow Creation Duplicate File Handling",
            },
            "sftp-polling-duplicate-workflow-version": <ConfigItemInfo>{
                "type": "*string",
                "default_value": NOTHING,
                "description": "the version of the workflow for duplicate file handling; if not set (the default), "
                    "the latest version will be used",
                "strictly_local": True,
                "config_group": "SFTP Polling Workflow Creation Duplicate File Handling",
            },
            "sftp-polling-duplicate-order-mapper": <ConfigItemInfo>{
                "type": "*string",
                "default_value": NOTHING,
                "description": "the mapper for creating duplicate orders, only used if "
                    "\"sftp-polling-file-connection\" and \"sftp-polling-duplicate-order-mapper\" are also set; the "
                    "local file path is available as \"$local:local_path\" and if "
                    "\"sftp-polling-duplicate-file-connection\" is set, then the new name is available as "
                    "\"$local:new_name\"",
                "strictly_local": True,
                "config_group": "SFTP Polling Workflow Creation Duplicate File Handling",
            },
        };
        # change default status of new workflow orders to BLOCKED for 2-phase commit
        rv."create-workflow-order-status".default_value = OMQ::StatBlocked;
        return rv;
    }
}
# END
