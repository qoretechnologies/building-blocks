# name: BB_RestActionStep
# version: 1.0
# desc: generic step for making a transaction safe REST request
# author: Qore Technologies, s.r.o.
%new-style
%require-types
%strict-args
%enable-all-warnings

%requires RestClient
%requires Swagger

#! this step building block creates an object in a remote REST server
/** This step building block is transaction safe; in case of an error, the validation logic will query the server
    using a unique key provided in the request if the config item \b \c rest-supports-validation is present
    to determine if the object was actually created in the original request or not

    Validation will determine that the REST call must be retried if one of the two conditions occurs:
    - A <tt>404 Not Found</tt> response is provided when queried with the unique request ID (generated from the
      \c \b rest-request-key-template config item; see @ref getUniqueRequestId() for details)
    - The request succeeds but the unique response ID (identified with config item \b \c rest-id-location) is not
      provided in the response

    If either of these conditions occur, the validation method will return @ref OMQ::StatRetry.

    If the validation response returns the unique

    The following configuration items are supported; note that subclasses must provide default values
    for required config items (in bold):
    - \b \c rest-connection-name: (required) the name of the REST connection
    - \b \c rest-api-mapper-name: (required) the name of the mapper for the REST call
    - \b \c rest-object-uri: (required) the URI path for creating and querying the object in the REST server
    - \b \c rest-supports-validation: (required) set to True if the request requires and supports validation,
      False if not; if True then \c \b rest-id-location, rest-get-id-key, and rest-request-key-template must be set
    - \b \c rest-id-location: (optional) location in the response for the unique ID in the POST response
    - \b \c rest-get-id-key: (optional) the key used to select the unique key for validation; this value is used in
      the URI path as a query argument for the validation GET request
    - \b \c rest-request-key-template: (optional) the template for the unique request key; see
      @ref UserApi::expandTemplatedString() for more information; default value:
      \c "$local:workflow_instanceid-$local:stepid-$local:ind"
    - \b \c object-name: (required) the name of the object for logging purposes
    - \c rest-swaggger-schema-resource: (optional) the name of the service resource (name:resource) for the Swagger
      schema for the REST connection (default empty = no swaggger schema service resource for REST client)
    - \c rest-sensitive-alias-input: (optional) a comma-separated list of colon-separated strings giving <input
      key>:<sensitive alias> values for the mapper input (default empty = no sensitive data input for mapper)
    - \c object-order-key: (optional) the name of the order key to set the unique ID from (default empty = do not set an
      order key)
    - \c object-dynamic-key: (optional) the name of the dynamic data key to set the unique ID in (default empty = do not
      set a dymamic key)
    - \c leave-parent-feedback: (required) set to true to leave feedback to the parent workflow order (default false)

    @note The swagger schema can be set in the REST connection itself; \c rest-swaggger-schema-resource is only for
    convenience in case the same Swagger schema is also used by a server-side service
*/
class BB_RestActionStep inherits QorusNormalStep {
    #! the primary step logic: create the object in the remote REST server
    primary() {
        # get the connection to the REST API
        RestClient rc = getConnection();
        # get mapper name
        string mapper_name = getConfigItemValue("rest-api-mapper-name");
        # get mapper to convert from order data to the REST call
        Mapper mapper = getMapper(mapper_name);

        # setup sensitive input if required
        hash<auto> sensitive_input;
        {
            *string aliases = getConfigItemValue("rest-sensitive-alias-input");
            if (aliases) {
                foreach string str in (aliases.split(",")) {
                    (*string key, *string alias) = (str =~ x/([^:]+):(.*)$/);
                    if (!key.val() || !alias.val()) {
                        throw "ALIAS-CONFIG-ERROR", sprintf("config item \"rest-sensitive-alias-input\" has "
                            "invalid value %y; expected a comma-separated list of <key>:<alias> values", str);
                    }
                    sensitive_input{key} = getSensitiveDataFromAlias(alias);
                }
            }
        }

        # setup raw data for making the REST API call
        hash<auto> input_data = {
            "static": getStaticData(),
            "context": getUserContextInfo(),
        } + sensitive_input;
        hash<auto> object_info = mapper.mapData(input_data);
        # get the URI path for the request for creating the object
        string uri_path = getConfigItemValue("rest-object-uri");
        bool validation = getConfigItemValue("rest-supports-validation");
        *string unique_id_loc = getConfigItemValue("rest-id-location");
        string rest_method = getConfigItemValue("rest-method");
        *hash<auto> hdr = getConfigItemValue("rest-headers");
        # create the object and get the unique ID
        hash<auto> info;
        logDebug("REST REQUEST: method: %y URI: %y args: %y", rest_method, uri_path, object_info);
        hash<auto> response = rc.doRequest(
            rest_method,
            uri_path,
            object_info,
            \info,
            NOTHING,
            hdr,
        );
        logDebug("REST REQUEST INFO: %N", info);
        logDebug("REST RESPONSE: %N", response);

        if (unique_id_loc) {
            # save the unique ID for further processing
            saveUniqueId(getUniqueId(response.body, unique_id_loc));
        }
    }

    # try to get object ID from the unique request ID
    /** this logic guarantees that we never create the object twice for the same request
    */
    string validation() {
        if (!getConfigItemValue("rest-supports-validation")) {
            logInfo("request does not support validation; retrying");
            return OMQ::StatRetry;
        }

        # get the connection to the REST API
        RestClient rc = getConnection();
        # get the URI path for the GET request for creating the object
        string get_uri_path = getConfigItemValue("rest-object-uri");
        # get the URI query key name for the GET request
        string key = getConfigItemValue("rest-get-id-key");
        # get the location of the unique ID in the response
        string unique_id_loc = getConfigItemValue("rest-id-location");
        # get unique request key
        string unique_request_id = getUniqueRequestId();
        # info hash for the REST GET request
        hash<auto> info;
        # for the REST response
        hash<auto> response;
        try {
            # try to retrieve object ID from the unique request ID
            *hash<auto> hdr = getConfigItemValue("rest-headers");
            response = rc.get(get_uri_path + "?" + key + "=" + unique_request_id, NOTHING, \info, hdr);
        } catch (hash<ExceptionInfo> ex) {
            # if not found, then retry
            if (info."response-code" == 404) {
                # no object exists; retry the object creation logic
                logInfo("%s %y not found; retrying", key, unique_request_id);
                return OMQ::StatRetry;
            }
            # for any other errors, rethrow the exception
            rethrow;
        }

        # unique object ID to be returned
        *string unique_object_id = getHashDotValue(response, unique_id_loc);
        if (!unique_object_id.val()) {
            logInfo("cannot find unique ID in response body in location %y; body: %N; retrying",
                unique_id_loc, response.body);
            return OMQ::StatRetry;
        }

        # object was created; save it and continue
        saveUniqueId(unique_object_id);
        # step has been recovered
        return OMQ::StatComplete;
    }

    #! returns the unique ID in the response
    /** @param response the response as returned from the HTTP server
        @param unique_id_loc the unique ID location

        @return the unique ID in the response

        @throw REST-REQUEST-ERROR if the unique ID cannot be found in the response
    */
    string getUniqueId(hash<auto> response, string unique_id_loc) {
        *softstring id = getHashDotValue(response, unique_id_loc);
        if (!id.val()) {
            throw "REST-REQUEST-ERROR", sprintf("cannot find unique ID in response body in location %y; body: %N",
                unique_id_loc, response.body);
        }
        return id;
    }

    #! saves the unique ID createed
    /** also stores it as an order key against the order, and returns it to the parent order as workflow order feedback
    */
    private saveUniqueId(string unique_object_id) {
        string object_name = getConfigItemValue("object-name");
        logInfo("SUCCESS: got %s %y for request", object_name, unique_object_id);
        # set order key if applicable
        *string key = getConfigItemValue("object-order-key");
        if (key.val()) {
            setOrderKey(key, unique_object_id);
        }
        key = getConfigItemValue("object-dynamic-key");
        if (key.val()) {
            updateDynamicData({key: unique_object_id});
        }
        # leave parent feedback if applicable
        if (getConfigItemValue("leave-parent-feedback")) {
            leaveParentFeedback(getUniqueRequestId(), unique_object_id);
        }
    }

    #! returns a REST connection to the server, optionally setting a Swagger schema from a service resource
    private RestClient getConnection() {
        # connection options, if any
        hash<auto> connection_opts;
        {
            # get Swagger schema resource name, if any
            *string schema = getConfigItemValue("rest-swaggger-schema-resource");
            if (schema) {
                (*string svc, *string rsc) = (schema =~ x/([^:]+):(.*)$/);
                if (!svc.val() || !rsc.val()) {
                    throw "SWAGGER-CONFIG-ERROR", sprintf("config item \"rest-swaggger-schema-resource\" has "
                        "invalid value %y; format <service>:<resource> is required", schema);
                }
                # get Swagger schema text
                schema = call_rest_api("GET", "services/" + svc + "/resource_files/" + rsc + "/data");
                # create Swaggger REST schema validator object
                SwaggerSchema swagger = SwaggerLoader::fromString(schema, False);
                connection_opts = {
                    "validator": swagger,
                };
            }
        }
        # get REST connecting and use validator, if present
        return getUserConnection(getConfigItemValue("rest-connection-name"), True, True, connection_opts);
    }

    #! returns a unique key for this step
    /** @return the return value is the value of
        @ref OMQ::UserApi::expandTemplatedString() "UserApi::expandTemplatedString()" called with the value of config
        item \b \c rest-request-key-template as an argument
    */
    private string getUniqueRequestId() {
        return expandTemplatedString(getConfigItemValue("rest-request-key-template"));
    }

    #! config items for this step
    private *hash<string, hash<ConfigItemInfo>> getConfigItemsImpl() {
        return {
            "rest-connection-name": <ConfigItemInfo>{
                "description": "the name of the REST connection",
            },
            "rest-method": <ConfigItemInfo>{
                "description": "the REST method to use",
                "default_value": "POST",
            },
            "rest-api-mapper-name": <ConfigItemInfo>{
                "description": "the name of the mapper for the REST call",
            },
            "rest-object-uri": <ConfigItemInfo>{
                "description": "the URI path for creating the request(s) in the REST server",
            },
            "rest-supports-validation": <ConfigItemInfo>{
                "type": "bool",
                "default_value": True,
                "description": "set to True if the request requires and supports validation, False if not; "
                    "if True then rest-id-location, rest-get-id-key, and rest-request-key-template must be set",
            },
            "object-name": <ConfigItemInfo>{
                "default_value": "request ID",
                "description": "the name of the object for logging purposes",
            },
            # optional items
            "rest-id-location": <ConfigItemInfo>{
                "description": "location in the response for the unique ID in the POST response",
            },
            "rest-get-id-key": <ConfigItemInfo>{
                "description": "the key used to select the unique key for validation",
            },
            "rest-request-key-template": <ConfigItemInfo>{
                "default_value": "$local:workflow_instanceid-$local:stepid-$local:ind",
                "description": "template for the unique request key; see UserApi::expandTemplatedString() for "
                    "information on supported substitutions",
            },
            "object-order-key": <ConfigItemInfo>{
                "default_value": "",
                "description": "the name of the order key to set the unique ID from",
            },
            "object-dynamic-key": <ConfigItemInfo>{
                "default_value": "",
                "description": "the name of the dynamic data key to set the unique ID in",
            },
            "rest-swaggger-schema-resource": <ConfigItemInfo>{
                "default_value": "",
                "description": "the name of the service resource (name:resource) for the Swagger schema for the REST connection",
            },
            "rest-sensitive-alias-input": <ConfigItemInfo>{
                "default_value": "",
                "description": "a comma-separated list of colon-separated strings giving <input key>:<sensitive alias> values for the mapper input",
            },
            "leave-parent-feedback": <ConfigItemInfo>{
                "default_value": False,
                "type": "bool",
                "description": "set to true to leave feedback to the parent workflow order",
            },
            "rest-headers": <ConfigItemInfo>{
                "default_value": {},
                "type": "hash",
                "description": "additional headers to send with each REST request",
            },
        };
    }
}
# END
