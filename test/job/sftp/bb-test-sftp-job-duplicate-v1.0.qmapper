# -*- mode: qore; indent-tabs-mode: nil -*-

# name: bb-test-sftp-job-duplicate
# version: 1.0
# desc: maps SFTP file events to workflow order data
# type: Mapper
# author: Qore Technologies, s.r.o.
# parse-options: PO_NEW_STYLE
# define-group: test: test interfaces
# define-group: bb-test: building block test interfaces
# groups: test, bb-test

OPTION: input: (
    "name": {
        "desc": "the name of the file, link, or directory",
    },
    "size": {
        "desc": "the size of the file in bytes",
    },
    "uid": {
        "desc": "the UID of the owner of the file",
    },
    "gid": {
        "desc": "the GID of the owner of the file",
    },
    "mode": {
        "desc": "the permissions / mode of the file",
    },
    "atime": {
        "desc": "the last accessed date/time of the file",
    },
    "mtime": {
        "desc": "the last modified date/time of the file",
    },
    "type": {
        "desc": "the type of file; one of: REGULAR, DIRECTORY, SYMBOLIC-LINK, BLOCK-DEVICE, CHARACTER-DEVICE, FIFO, SYMBOLIC-LINK, SOCKET, or UNKNOWN",
    },
    "perm": {
        "desc": "a string giving UNIX-style permissions for the file (ex: '-rwxr-xr-x')",
    },
    "data": {
        "desc": "this key is only present if \c sftp-polling-file-connection not set; in this case the remote file data is retrieved in memory and stored in this key as binary data",
    },
    "filepath": {
        "desc": "the remote filepath relative to SFTP root directory",
    },
    "local_path": {
        "desc": "this key is set to a string giving the local path where the file's data is stored if config item \c sftp-polling-file-connection is set",
    },
    "new_name": {
        "desc": "the new name of the duplicate file",
    }
)

OPTION: output: (
    "staticdata": {
        "type": "hash",
        "desc": "the initial static data for the order",
        "mand": True,
    },
    "dynamicdata": {
        "type": "hash",
        "desc": "the initial dynamic data for the order",
    },
    "global_unique_key": {
        "type": "hash",
        "desc": "a hash giving one or more unique order keys for the order (across all workflows regardless of "
            "workflowid, name, or version); keys are order key names and values are the string key values; if this "
            "key already exists for any order in the system, then the order creation will fail with a "
            "DUPLICATE-ORDER-KEY error; the hash key must be a valid order key, and the value is the unique key "
            "value; this value will also be created as an order key",
    },
    "workflow_specific_unique_key": {
        "type": "hash",
        "desc": "a hash giving one or more unique order keys for the particular workflowid (which matches a "
            "unique name and workflow version); keys are order key names and values are the string key values; if "
            "any of the keys given already exists for an order with the target workflowid, then the order "
            "creation will fail with a DUPLICATE-ORDER-KEY error; the hash key must be a valid order key, and the "
            "value is the unique key value; this value will also be created as an order key",
    },
    "workflow_unique_key": {
        "type": "hash",
        "desc": "a hash giving one or more unique order keys for the particular workflow by name only (across all "
            "workflows with the same name regardless of version); keys are order key names and values are the string "
            "key values; if this key already exists for a workflow order with the same name, then the order creation "
            "will fail with a DUPLICATE-ORDER-KEY error; the hash key must be a valid order key, and the value is the "
            "unique key value; this value will also be created as an order key",
    },
    "orderkeys": {
        "type": "hash",
        "desc": "a hash of order keys for the order",
    },
)

FIELD: staticdata: {"name": "local_path", "code": hash<auto> sub (*string local_path, hash<auto> rec) { return rec; }}
FIELD: workflow_unique_key: {"name": "new_name", "code": hash<auto> sub (string new_name, hash<auto> rec) { return {"filename": new_name}; }}
FIELD: orderkeys: {"name": "name", "code": hash<auto> sub (string name, hash<auto> rec) { return {"orig_name": name}; }}
# END
